object类是所有类的父类，所以是可以被继承的，object类的tostring方法是可以被重写的。但是string类是被final修饰的，被final修饰的类是不可以被继承的，所以string类就不存在与任何类有继承关系，
也就是说所有的方法都没办法被重写。
继承有什么优缺点？优点：子类可以自动继承父类的对象；在创建子类的时候不需要再创建父类的对象。缺点：破坏封装，子类与父类的耦合性过高，子类过度依赖父类的实现，子类不能独立。
支持扩展，却是以增强结构的复杂度为代价。不能动态继承，在运行时，子类不能随意选择不同的父类。子类不能更改父类的接口。
接口的优缺点？类与接口的关系是实现关系，类可以实现很多接口，但类与类之间只能进行单继承，打破了继承的局限性。对外提供规则，降低了程序的耦合性。
抽象类与接口的区别？共同点：都是没有具体实现的方法，也不能实例化（没有对象）区别：与类的关系？抽象类与类的关系是继承关系，一个类只能继承一个类，而类可以实现多个接口。
与变量的关系？抽象类有成员变量，也可以有常量；接口只能有常量，默认修饰符是 public static final。与构造方法的关系？抽象类有构造方法，为子类提供；接口没有构造函数。
与方法的关系？抽象类可以有抽象方法，也可以有非抽象方法；接口只有抽象方法，默认修饰符是public abstract.
redis的基本数据类型？1、string（字符串） 2、hash（字典）3、list（列表）4、set（集合）5、zset（sorted set）有序集合
spring和springMVC的区别？spring是ioc和aop的容器框架，springmvc是基于spring功能之上的web框架；所以使用springMVC必须依赖于spring；
spring是管理bean的容器，也就是管理许多项目的容器。springMVC只是其中一个开源项目。
final、finally、finalize的区别？final是修饰符，可以用来修饰类，方法、变量；final修饰类时不可以被继承；final修饰的方法不可以被重写；final修饰的变量不可以被改变。
finally是用来异常处理的，提供finally代码块进行处理工作的。finalize是Object类的方法名，垃圾收集是发现该对象不再引用时，垃圾收集器会在该对象上调用该对象。是垃圾收集器在删除对象之前对该对象调用的。
检查异常和运行时异常？检查异常（非运行时异常）编译器强制要求进行处理的异常，不处理将无法进行编译。有FileNotException，SQLException,ClassNotFoundException,IOException,ParseException;
运行时异常：编译器并不强制要求处理的异常，可以是在运行时出现异常再进行处理，比如ClassCastException，ArrayIndexOutOfBoundsException；NullPointException；ArithMeticException；NumberFormatException；
void表示无返回值，就是调用完毕后无结果给调用者。可以没有return；但是有返回值，必须使用return。返回值可以是任何类型（八种基本数据类型和引用类型）
方法（函数）的定义：体现的是功能。程序模块的设计，便于反复调用。
继承有什么优缺点？子类可以自动继承父类的对象，在创建子类的对象时，不需要再创建父类的对象。缺点：破坏封装，子类与父类的耦合性过高，子类过度依赖父类的实现，子类不能独立运行。
支持扩展，一般需要增加结构的复杂度。在运行时，子类不能随意选择不同的父类，子类不能改变父类的接口。
jdk的新特性：default关键字；lamba表达式了，函数式接口，方法与构造函数调用，局部变量限制
为什么要进行sql优化？随着业务的增加，sql的执行效率对程序的运行效率影响逐渐增加。优化的一些方法：应避免进行全表扫描，多使用where子句和order by子句；应避免where 子句使用null值判断；
应避免使用!=或<>操作符。避免使用or进行连接操作。也尽量避免使用in或not in ，否则引擎都将会放弃索引进行全表扫描。
索引的作用？为了提高检索的效率。有几种索引？普通索引；唯一索引；主键索引；复合索引；单列索引 索引就相当于图书的目录，可以根据目录快速找到所需的内容。
String str = “ABC” 和String str = new String（abc)创建几个对象？前者一个，后者两个！先看看常量池，如果没有，先在常量池创建一个；如果有，前者直接调用，后者再创建一个。
对于基础类型的变量和常量？变量和引用类型放在栈内存中，常量放在常量池中。
string，stringBuffer，stringbuilder的区别？string类是被final修饰的，不可以被继承，String是常量，创建好之后就不可以被改变了。可以通过stringBuffer和stringbuilder创建对象，两个都是string的常用操作类。
stringbuffer类是同步的，绝大多数方法都是被synchronized修饰的，使用tostring会缓存对象，以减少元素复制开销。
stringbuilder类和stringbuffer实现和继承了同样的接口和类，唯一的区别就是它是非同步的，使用tostring（）会返回一个新的对象。
arraylist和linkedlist的区别？arraylist的底层基于数组，数组在内存中是一块连续的区域，便于进行查询操作；linkedlist的底层基于链表，与数组相反，链表不要求连续，有利于扩展，便于进行增删改操作；最后linkedlist比arraylist更占内存，linkedlist每个节点都占据了两个引用，一个指向前一个元素，一个指向后一个元素。
讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当 new 的时候， 他们的执行顺序。父类静态变量，父类静态代码块，子类静态变量，子类静态代码块，父类非静态变量，父类构造函数，子类非静态变量，子类构造函数。
hashMap的特点：根据hash算法进行排序，执行效率块，因为是不同步的，允许key为null;与hashtable的区别？hashtable的用法与hashmap的用法几乎一致，区别是同步的，线程安全，不允许key为null;
抽象类与接口的区别？共同点：都是只有没有具体实现的方法，也不能实例化。类与类之间只能进行单继承，接口却可以继承多个接口，类却可以实现多个接口。与方法的关系？抽象类可以有抽象方法，也可以有非抽象方法，接口只能有抽象方法，默认修饰符是public abstract；抽象类可以有成员变量，也可以有常量；接口只能有常量，默认修饰符是public static final;抽象类可以有构造函数为子类提供，接口没有构造函数。
获取类的class对象？创建一个类的对象，通过这个类调用Object类的getClass();A a = new A();   class a1 = a.getClass();每一个类都有一个属性class:Class a2= A.class;调用Class类的静态方法forName(); Class c3= Class.forName();A a3 = c3.newInstance()；
动态代理的几种方式？jdk动态代理和cglib动态代理；jdk动态代理是利用反射机制，需要基于接口，有很大限制；cglib动态代理是基于asm框架的，无反射机制利用。
四大修饰符:修饰符的作用是主动标识修饰块的作用域，方便隔离保护；public修饰符：公开的，所有类都可以访问的；protect修饰符：受保护的，本包的和所有子类可以访问；default修饰符：缺省的；本包的可以访问；private修饰符：私有的；只有本类的对象可以访问
数组和链表的区别？数组的元素在内存中是一块连续的区域；每个元素在内存中都占据相同的空间，所以可以通过下标法很容易找到需要的元素，但是需要添加一个元素的话，就需要移动大量的元素，腾出一个空间来放置这个添加的元素，同理，删除也是一样的；所以，数组适合做查询操作，不利于扩展。
链表的元素在内存中则不是按顺序连接的，而是通过元素中的指针进行连接的；每个结点都有两个部分，一个是数据元素的数据域，一个是存储下一个结点地址的指针；如果需要往链表里面增删元素的话，只需要更改元素的指针即可，这很容易，但是查询需要的话，则需要从第一个元素一直找，找到被需要的元素为止，所以链表对于查询很麻烦，适合做增删操作。
Error和Exception的区别？ Exception和Error是Throwable的子类；Error是系统级的故障，不是程序员可以解决的；Exception是可能程序员在编写代码时疏忽造成的异常。Exception分成CheckedException和RuntimeException；checkedException有FileNotFoundException,ClassNotFoundException,SqlException,IOException,ParseException;
RuntimeException:ClassCastException；ArrayIndexOutOfBoudsException;ArithmeticException;NumberFormatException;NullPointException;怎么处理异常呢；如果知道怎么解决的话我会使用try catch，如果不知道怎么解决的话我就在方法上声明异常抛出。
hashset和hashmap如何做到元素不重复的？hashset的add（）底层是调用hashcode（）和equals（），当添加一个元素，先调用hashcode将对象转化成hahcode值，进行hash值对比，不相等的直接放入集合，hash值相等的再进行equals（）进行比较，两个不同的对象hash值可能会相同，equals（）对比的是对象的内容，如果相同，说明元素重复，不放入集合，如果相等则说明是新元素，放入集合。
序列化和反序列化？序列化就是把java对象转化成字节序列的过程，反序列化就是把字节序列转化成java对象的过程。
为什么要进行序列化？在不同进程中远程通信是可以互相传送数据的，包括图频数据，java对象不能传输，需要转化成二进制序列进行传输。
怎么进行序列化？实现serializable接口同时会添加serialVersionUID版本号，这个版本号就是验证反序列化的是否是同一个类。序列化是通过ObjectOutputstream类的writeObject()实现的，反序列化是通过ObjectInputStream类的readObject()实现的；
反序列化可能会出现什么问题？当没有显示序列版本号SerialVersion时，如果对象的需求发生改变，兼容性会发生破坏，会发生InvalidClassException异常。
jdk和jre有什么区别?JDK是java开发工具包，提供了java的运行环境和开发环境；jre是java运行环境，为java提供了运行时需要的环境。具体来说，jdk包含了jre，还包括了java源码的编译器javac,还有java程序调试和分析的工具，如果只需要运行Java程序，安装jre就够了，如果需要编写java程序，则需要安装jdk；
equals和==有什么区别？==对于基本数据来说是进行值比较，对于引用类型来说，比较的是在内存中的地址；object类的equals（）本质上和==是一样的。但是String，Integer都对他进行了重写，在重写了之后，equals（）原本是进行引用比较的，也变成了值比较。
Math.round()是四舍五入    Math.round（-1.5）=-1;           让字符串翻转的函数？先把字符串放入stringBuffer或stringBuild中，然后调用StringBuffer.reverse();
string类的方法？equals();trim();equals();length();replace();
io流分为几种？按功能分为输入流和输出流；按类型来说分为字节流和字符流。字节流和字符流的区别？字节流是以8位传输字节为单位进行输入输出的；字符流是以16位传输字符为单位进行输入输出的；
Files的常用方法？Files.exists()检测文件路径是否存在；Files.createFile()创建文件;Files.createDirectory创建文件夹；Files.delete()删除文件或者文件夹；Files.copy()复制文件；Files.size()文件个数；
list、set、map的区别？list和set都继承了collection接口，list的子类有ArrayList和LinkedList和vector；list里的元素可以重复。arraylist的底层基于是数组，便于做查询操作，linkedlist的底层基于是链表，便于做增删操作；vector是同步的，线程不安全,list和set有get，remove，size等方法。set的子类有hashSet;treeset;linkedhashset;linkedhashset是hashset的子类；map的子类有haspmap，hashtable，treemap，hashtable是同步的，线程安全的；有put()，remove（）方法；map和set的元素都不可以重复。
数组和ArrayList如何转换？Arraylist转换成数组调用arraylist.toArray();数组转化成list集合，调用Arrays.aslist();
arrayslist和vector的区别？vector是同步的，线程安全；Arraylist是异步的，效率更快，不会过载。
array和arraylist的区别？array可以存储基本类型和对象，arraylist只能存储对象；array是指定大小的，arraylist初始化大小是固定的。array没有arraylist的功能强大，比如addAll（），removeAll(),iterator;
在queue（队列）中poll（）和remove（）有什么区别？poll（）和remove（）都是从队列中取出一个元素；poll（）在获取元素失败的时候会返回null，remove()失败的话会报出异常。
有哪些线程是安全的？vector；statck是堆栈类，先进先出；hashtable；enumeration：枚举，相当于迭代器。
迭代器（iterator）是什么？iterator是一种设计模式，是一个对象，用来遍历并选择序列中的对象。
iterator怎么使用，有什么特点？当调用iterator()时要求容器返回一个iterator,当iterator第一次调用next()，会返回序列中的第一个元素。iterator()是java.lang.iterable,公共基类collection提供的。
调用next()返回的是序列中的下一个元素。调用hashnext()是检查序列中是否还有元素。调用remove()可以将迭代器返回的新元素删除；这个迭代器比较简单，只能单向迭代。
iterator和ListIterator的区别？iterator可以遍历list集合和set集合；listIterator只能用来遍历list集合。iterator只可以单向遍历，listIterator可以双向遍历。listIterator是iterator的子类，不仅实现了全部的功能，同时也扩展了新功能，比如add()增加元素；set()替换元素,previous（）获取上一个元素。
java的反射机制？是指java程序在运行时动态获取类的所有属性和方法，并实例化该类，调用方法的功能。
tomcat如何调优，涉及什么参数。硬件的选择，操作系统的选择，版本号的选择，jdk的选择，配置jvm的参数，配置connector的线程数，集群，开启gzip；
1）内存优化；优化tomcat启动的参数，比如修改tomcat启动脚本的最大内存；2）线程数优化：优化tomcat的并发线程数，比如修改servlet.xml中的最小空闲连接线程数，提高系统的处理效率；3）优化缓存：打开压缩功能修改参数，比如压缩文件输出内容的默认容量为2kb，可适当修改。
spring的事务配置：1）基于xml的事务配置  2）基于注解的事务配置。
spring的作用？spring是开源框架，它可以帮助我们减少工作量，提高工作效率，spring是分层结构，即对应的层处理对应的逻辑关系，减少代码之间的耦合性。
spring的核心就是ioc控制反转和aop面向切向编程。控制反转的意思是程序之间的关系由容器来管理的，容器管理对象，容器提供外部资源。反转则是过去是由我们创建对象依赖对象，现在则是由容器创建获取对象，对象是被获取，所以是反转。
Aop 面向切面编程，主要管理系统层的业务，如日志，权限，事务等，aop是将封装好的对象剖开，取出对多个对象产生影响的公共行为，并将它封装成可重用的模块，这就是切面。切面与业务逻辑无关，但是业务却共同调用逻辑并封装起来，减少代码的重复性，增加可重复的模块，降低模块之间的耦合性，提高了程序的可维护性。
spring是开源框架，它能够帮助我们减少工作量，提高工作效率，同时spring是分层结构，即对应的层处理对应的业务逻辑。spring的核心是IOC控制反转和AOP面向切面编程。IOC强调的是程序之间的关系是由容器来管理的，容器控制对象，并提供外部资源。反转则是在传统的编程中是由我们创建对象并获取依赖关系，现在则是由容器创建对象并注入依赖对象，是容器帮我们查找和注入对象，对象被获取，这就是反转。
Aop就是面向切面编程。主要管理系统层的业务，比如日志，权限，事务等，aop就是把封装好的对象剖开，把对多个对象产生影响的公共行为提取封装起来，就是切面，切面就是将与业务逻辑无关，但是又被业务模块共同调用的逻辑提取并封装起来，这样减少了程序的重复代码，降低了模块间的耦合性，提高了系统的可维护性。
spring的核心组件是bean context core ;单例注入是beanfactory创建的。生命周期是在创建的时候实现接口开启的，循环注入后置处理器，aop是通过反射机制进行代理的，比如advice；
事务的特性和理解？事务的特性有原子性，一致性，持久性，隔离性；原子性是指在一个事务中，要么全部执行成功，要么全部失败回滚。一致性是指事务在执行前状态和执行后的状态是一致的。持久性是指事务对数据的操作是永久性的。隔离性是指当一个事务对数据进行操作时，其他事务则不能对该数据进行操作。
程序、进程、线程的区别？程序就是一组有序指令的集合。进程：就是程序的一次执行。线程：是CPU的基本调度单位，轻量级的。一个进程可以包含多个线程。
单线程和多线程的区别？单线程：主函数就是单线程，函数从上往下执行，效率低；多线程：效率高，不可控。
sleep（）和wait（）的区别？sleep是使线程休眠。wait()则是等待，要求和synchronized一起使用。sleep是thread类的静态方法，wait（）是Object类的方法。sleep依旧持有锁，且会在指定时间内被唤醒，wait则是释放锁。
synchronized和lock锁的区别？首先两者在并发情况下都保持了原子性和可见性。但是synchronzied在释放的时候交由自身控制，而且无法干预，不可人为中断。而lock是由我们手动释放锁，常用的有reentrantlock和readwritelock，添加了定时锁等候和中断锁等候的操作的特性，而且在一些激烈情况下具有更佳的性能。
说说你知道的几种锁？公平锁和非公平锁，可重入锁，独享锁和共享锁；公平锁就是多个线程按照申请锁的顺序获取锁，非公平锁则相反。可重入锁，也叫递归锁，就是同一个线程在外部方法获取锁，进入内层方法则自动获取锁。独享锁就是该锁一次只能被一个线程所持有；共享锁就是该锁可以被多个线程所持有。还有乐观锁，悲观锁。
sychronized修饰的静态方法和方法有什么区别？synchronized static 表示某个类的范围，防止多个线程对这个类的synchronized static方法进行访问，是对这个类的所有实例对象起作用。synchronized表示某个实例的范围，防止的是多个线程对这个实例的synchronized修饰的方法进行访问。
私有属性可以被继承吗？可以，但是子类不可以直接访问，要通过父类的非私有方法访问。
HTTP的响应码？1字开头的，信息；2字开头的，成功；3字开头的：重定向；4字开头的：客户端错误；5字开头的：服务器错误。
URL和URI的联系与区别？URL是某一信息资源在网络上唯一的地址，Url由4部分组成：协议、主机、端口、路径组成。URI是统一资源标志符，是用于标识某一互联网资源的字符串。URI是由URI协议，存有该资源的IP地址，主机资源的具体地址。URL是一种URI，URI可以算作由url和urn两部分，urn可以类似于一个人的名字，url类似于这个人的居住地址，urn代表某种事物的身份，url则代表寻找该事物的方法。
守护线程（demo thread），用来服务其他线程的线程。
创建线程的几种方式？1、继承thread类，重写run（），run()表示的就是线程要完成的任务，run（）又被称为执行体。2、实现Runnable接口，重写该接口的run(),run()同样是该线程的执行体。3、实现Callable接口，实现该接口的call（），call()是该线程的执行体，并有返回值。
Runnable接口和Callable接口的区别？Runnable的run()是没有返回值的，只是单纯的执行run()中的代码。Callable的call()是由返回值的，是一个泛型，与futuretask类配合获取返回值。
restful架构具有扩展性强，结构清晰的特点。restful将服务器分成前端服务器和后端服务器。前端服务器为用户提供无模型的视图，后端服务器为前端服务器提供接口，浏览器向前端浏览器请求视图，通过视图包含的Ajax函数向接口请求获取模型。
restFul架构具有扩展性强，结构清晰等特点；restFul将服务器分为前端服务器和后端服务器，前端服务器为用户提供无模型的视图，后端服务器为前端服务器提供接口，浏览器向前端服务器请求视图，通过视图包含的Ajax方法向接口请求获取模型。
rpc是远程过程调用的意思，类似于三层分层架构的C/S架构，第三端客户程序通过接口调用SAP内的标准和自定义方法，获取方法返回的数据进行处理。
restful和RPC的区别？都是客户端获取数据的方式，restful是基于HTTP协议的，而RCP基于TCP/IP协议，Http协议是在TCP/IP协议之上的， 所以RCP效率更快。restful是客户端与服务器之间的交互，对于接口少，系统之间的交互少的情况下一般选择是restful架构，而对于内部子系统较多，接口较多的情况下，最好选择RPC，RPC是远程过程的调用的意思，第三方客户程序通过接口调用SAP内部的标准和自定义方法，获得方法返回的数据进行处理，尤其适合于偏大型公司。两者并没有高低之分，要看实际情况使用。
runnable和callable的区别？runnnable接口的run()方法没有返回值，只是单纯的执行run()里的代码；callable接口的call()是有返回值的，是一个泛型，与future类、futuretask类配合获取异步执行的结果。
创建线程的几种方式？继承thread类：定义thread类的子类，并重写run()方法，run（）的方法体就是该线程要完成的任务，run（）就是该线程的执行体。实现runnable接口，定义runnable接口的实现类，并重写run（），该run（）同样是线程的执行体。实现callable（）接口，定义callable（）接口的实现类，并重写call(),call()是线程的执行体，并且有返回值。
线程分为几种状态？创建、就绪、运行、阻塞、死亡。创建状态：当生成线程对象，还没有调用start（），线程处于创建状态；就绪状态：线程对象调用了start(),但是线程调度程序还没有将该线程设置成当前线程，线程就处于就绪状态。
运行状态：线程调度程序把处于就绪状态的线程设置成当前线程，此时线程就处于运行状态。阻塞状态：线程在运行时，被暂停，通常是为了等待某个时间点后再继续执行。死亡状态：线程的run（）执行结束或调用stop()后，该线程就死亡了。
sleep（）和wait()有什么区别？sleep()是让线程休眠，wait()则是等待，一定要和synchronized一起使用。sleep是Thread类的静态方法，wait()是Object类的方法。sleep()依旧持有锁，且会在指定时间内被唤醒。wait（）则是释放锁。
notify（）和notifyAll()的区别？当线程调用对象的wait(),那么该线程就进入了对象的等待池中，等待池的线程不会竞争该对象的锁。当对象调用了nitify(),就随机唤醒了等待池中的线程进入锁池中竞争锁的机会；notifyAll()则是唤醒等待池中所有的线程进入锁池竞争锁。
run()和start()的区别？每个线程都是通过某特定的thread对象调用对应的run()完成其操作的，run（）被称为线程体，=通过Thread类的start()来启动一个线程。通过调用start()，真正实现了多线程运行。无需等待run方法体执行完毕，可以直接执行下面的代码，这时此线程处于就绪状态，还没有运行，还需要通过此线程的Thread类的run（）来完成其运行状态，这时run()称为线程体，包含了该线程要执行的内容，直到run（）执行完毕，cpu再调用其他线程。run()只是线程的一个普通函数，只有一条执行路径，所以在多线程执行情况下使用start()而不是run().
spring?spring的作用是为了减少工作量，提高工作效率，同时也是分层结构，即对应的层处理对应的业务逻辑。spring的核心是IOC和AOP，ioc是控制反转的意思，强调的是程序之间的关系由容器来控制，容器控制对象，容器获取外部资源。反转则是传统的编程是由我们创建对象依赖对象，而在IOC中则是由容器帮我们创建对象注入依赖关系，正是容器查找和注入对象，对象被获取，这就叫反转。AOP则是面向切面编程。主要是管理系统层的业务，比如日志、权限、事务等等。AOP将封装好的对象剖开，取出对多个对象产生影响的公共行为封装成可重用的模块，这个模块就是切面。切面就是将与业务逻辑无关，但是却影响业务的逻辑提取并封装起来，这样减少了重复性的代码，降低了模块间的耦合度，提高了系统的可维护性。spring的核心组件是bean、context、core;单例注入是beanfactory创建的，它的生命周期是通过接口实现开启的，循环注入是通过后置处理器，AOP是通过反射进行动态代理的。
bean标签的常用属性scope：表示对象的作用域和生命周期；默认取值是sinleton,即单例模式创建对象。prototype：多例模式，即每次都创建一个新的对象。request：适用于web，与请求线程绑定，根据不同的请求对象创建不同的对象。session:适用于web环境，与会话线程绑定，根据不同的会话对象创建不同的对象。global-session：适用于web环境，应用作用域。
Aop的底层实现的是动态代理技术，动态代理分为jdk动态代理和cglib动态代理。为什么称为动态代理？因为代理类对象是动态生成的，就是不需要源码，在内存中自动生成字节码，以字节码为模板创建对象。jdk动态代理是字节码生成技术为实现接口的类创建代理类对象，没有实现接口的类则不能创建代理类对象。cglib动态代理：没有实现接口的类就使用cglib动态代理。字节码技术要求代理类对象在内存中继承目标类，这样代理类就具备了目标类的方法，可以扩展出切面功能，再去调用目标类的方法。
springMVC的简介：springMVC是spring的子模块，也是单独的一个框架。SpringMVC是对servlet进行了轻量级的封装，与servlet行成了良好的解耦。springMVC作用于MVC分层结构中的controller层，可以用springMVC代替servlet编程。
springMVC入门流程：1、加入jar包，2、配置前端处理器Dispatcherservlet,一般在web.xml文件中配置。3、初始化springMVC.xml文件。（1）开启springMVC注解 ；（2）配置视图解析器ViewResolver（如果使用前后分离的话，viewResolver将无法使用） (3)开启springIOC注解
springMVC注解的注意事项@RequestMapping 提供了映射规则，把url请求和控制器进行相互映射，默认支持get（）和post();如果放在类上，一般按模块划分，则说明这个类的所有方法都是用来处理这个模块业务的。如果标注在方法上，则说明这个方法是用来处理什么业务的。
前后端分离的注意事项：1、HTML页面要放在webapp目录下 2、控制器方法返回值是json类型的。3、视图解析器viewResolver将会失效。
springMVC中的乱码问题怎么解决？可以使用springMVC提供的CharacterEncodingfilter乱码处理器解决。
springMVC的异常处理器：内置异常处理器，适合处理全局异常      自定义异常处理器：分为两个步骤：1、编写异常处理器类 2、将异常处理器注册到spring中的bean中
springMVC的拦截器：是springMVC基于AOP机制的组件，该组件可以在控制器方法执行前后进行一些预处理和后处理。
restful具有扩展性强，结构清晰等特点，restful把服务器分为前端服务器和后端服务器，前端处理器向客户端提供无模型的视图，后端服务器向前端服务器提供接口，浏览器向前端服务器请求视图，通过视图包含的ajax()向接口请求获取模型。restful也可以理解为对URL的一种约束，如果都按照这个约束，那么格式将会更统一，更易读；restful是把路径上包含的对应的内容都看作是一种资源。
Mybatis是目前用的最多的持久层框架，可以进行传统数据库的操作，比如参数的设定，结果集的返回，动态语句的拼接提供解决方案。
Maven是一种基于项目对象模型的纯java开源的项目管理工具。
sqlSession是Mybatis和数据库之间的会话对象，这个对象调用Mybatis的API来完成对数据库的操作，每一个会话对象都是由sqlSessionFactory来创建的，该工厂的对象通过sqlSessionfactoryBuilder读取配置文件构建。
sqlsession是Mybatis和数据库之间的会话对象，这个对象调用Mybatis的API来完成对数据库的操作，每一个会话对象都是sqlsessionfactory来创建的，该工厂的对象通过sqlsessionfactoryBuilder读取配置文件来构建的。
springMVC的九大组件：MultipartResolver（文件处理器），localResolver（当前环境处理器），viewResolver(页面喧染处理器)，themeResolver（主题处理器）,HalderResolver（处理器映射器）;HalderExceptionResolver(异常处理）
Mybatis的缓存机制：Mybatis提供查询缓存，如果缓存中有数据将不会从数据库中获取数据，这样可以减少数据压力，提高系统性能。
Mybatis分为一级缓存和二级缓存，一级缓存是sqlsession级别的，对数据库进行操作需要创建sqlsession对象，这个对象有一个区域（hashmap）用于存储数据缓存，不同的sqlsession对象的数据缓存区域是互不影响的。二级缓存是mapper级别的，多个sqlSession可以去操作同一个mapper的sql语句，多个sqlsession可以共用一个mapper，二级缓存是夸sqlsession的。
Mybatis的缓存机制分为一级缓存和二级缓存，一级缓存是sqlsession级别的，对数据库进行操作需要创建sqlsession对象，这个对象有一个数据结构（hashmap）用于数据缓存的，不同的sqlsession对象之间的数据缓存区域是互不影响的。二级缓存则是mapper级别的，多个sqlsession对同一个mapper的SQL语句进行操作，多个sqlsession共用mapper，二级缓存是跨sqlsession的。一级缓存是默认开启的，二级缓存需要手动开启。
集群就是同一个业务在不同的服务器上运行；分布式就是同一个业务分成不同的模块在不同的服务器上部署。
Mybtis的优点：基于SQL语句的编程，相当灵活，对应用程序和数据库的现有设计不会造成影响。与spring有很好的继承，提供映射标签，支持对象与ORM字段关系映射，提供对象关系映射标签，支持对象关系组件维护。
Mybatis的缺点：sql语句编写量大，尤其是当关联表比较多时；sql语句必须依赖sql，不能随意更换数据库。
#{}和${}的区别是什么？#{}是预编译，${}是替换字符串。Mybatis在处理#{}的时候，会把#{}看做？号，然后再调用preparedStatement的set()来赋值，Mybatis在处理${}的时候，会把${}替换成变量的值。使用#{}可以有效防止SQL注入，提高系统安全性。
什么情况下适合使用索引？中、大数据量适合使用索引。
数据库引擎有几种？InnoDB、MyISAM、memory；
InnoDB和myISAM的区别？InnoDB支持事务安全，myISAM和memory不支持。InnoDB的插入效率较低，MyISAM和Memory的插入数据效率较高。
sql的左连接、右连接、全连接、内连接。内连接：查询两个表返回共同的区域。外连接：使用union或union all关键字。全连接是将两个表合并。union会去掉重复的数据，union all则会保留重复的区域。左连接：以左表为主，右表记录不足的地方均为null;右连接：以右表为主，左表记录不足的地方均为null。
jdbc的实现步骤：1、注册驱动  2、创建连接(collection) 3、创建和准备sql语句  4、执行sql语句   5、处理运行结果   6、释放资源
cookie和session的区别？cookie是在客户端记录信息确认用户身份，也就是cookie数据存放在浏览器上，session则是在服务器上记录信息确认用户身份，也就是session数据存放在服务器上。如果考虑安全的话，应当使用session；如果考虑服务器的性能的话，应当使用cookie；单个cookie的大小不能超过4k；应当把重要信息放在session中，其他信息需要保留的话可以放在cookie上。
SQL是结构化查询语言，用于对关系型数据库进行操作。关系型数据库则是现实生活中的实体，转换为数据库中的表，表的结构是二维结构。
redis的特性：是键值对结构的非关系型数据库，是基于内存进行数据存储的，所以读写速度比较快。是C语言开发的，读写速度比文件读写速度要快的多。是单线程，不用考虑线程并发问题。
redis是键值对结构的非关系型数据库，是基于内存进行数据存储的，所以读写速度比文件读取速度要快；是C语言开发的，单线程的，所以不用考虑并发安全问题。
redis的持久化机制:redis是基于内存进行数据存储的，如果redis关闭重启，要想数据不丢失，则必须要将redis的数据持久化；所谓的持久化就是redis以某种特定的策略将内存中的数据同步到硬盘中，就算redis重启数据也不会丢失。
redis的持久化方案：RDB模式是默认开启的，就是将内存中的数据达到某种条件后一次性写到硬盘中，在这种模式下，不建议往redis中存储重要信息；AOF模式则是将redis的每一次修改都会将数据写到硬盘中，但是需要手动开启。
redis的主从复制：设置一台redis为主服务器，这个主服务器下面可以有多个从服务器，主服务器的每次改动都会将数据同步到从服务器，如果主服务器发生意外不能运行时，则会将某一台从服务器设置为主服务器，继续为系统提供redis的相关服务，同时也继续将数据同步到从服务器中。
redis的基本类型：string（字符串），hash（字典），list（列表），set（集合），zset（有序集合）
statement与preparedment的联系与区别？联系：preparedstatement继承自statement，都是接口 区别：preparedment可以使用占位符，是预编译的，批处理要比statement有效率的多。statement每次对数据库的操作都要进行编译。
session和cookie的区别？session是在服务器上记录信息确认用户身份的，也就是说session数据是存放在服务器上的，cookie是在客户端上记录信息确认用户信息的，就是把数据存放在浏览器上；如果只考虑安全的话，建议使用session，如果考虑服务器性能的话，建议使用cookie，单个cookie数据的大小限制不能超过4k,应当把重要信息存放到session中，其他信息需要存储显示的话则使用cookie；
session是什么的抽象？服务器
jsp和servlet的区别？jsp本质上就是servlet，jsp经过编译就变成了servlet；jsp更擅长页面表示，servlet更擅长逻辑控制。
ajax的异步和同步的区别？我们使用ajax一般会采用异步处理。异步处理：就是通过ajax向服务器上发送请求，无论服务器响不响应，客户端的其他代码都会运行。同步处理：就是ajax向服务器发送请求时，在服务器处理请求的期间，客户端不能做其他事情，只有当ajax执行完毕后，客户端的其他代码才会运行。async：true 是异步； async：false是同步。
使用ajax跨域问题：我比较常用的是在ajax里添加属性：xhrFields{withCredentials：true}，可以指定某个请求发送凭据。
spring处理全局异常的方法：1、springMVC提供的simpleMappingExceptionResolver异常处理器  2、实现spring的异常处理接口HalderExceptionResolver实现异常处理 3、使用@ExceptionHalder注解实现异常处理。
springboot的目的是简化spring的配置，支持全注解配置，减少了xml文件繁琐的配置；@springbootapplication是spring的核心注解，由三个注解组成@springbootconfiguration是spring中@configuration的封装，用来代替applicationContext.xml配置文件，配置文件的数据注入则由子注解：@Bean，@ImportResource，@Import三个组件完成。@Componentscan，用于组件扫描 @EnableAutoConfiguration用于完成自动装配，是三个注解中最重要的。
springboot不建议使用jsp，建议使用thymeleaf.
springboot的优缺点：1、快速构建项目 2、与主流开源框架无配置集成  3、可以独立运行项目，无需依赖外部servlet容器  4、极大的提高了开发、部署的效率；缺点：1、版本迭代太快，有时变动会比较大 2、由于不需要自己配置，报错时会很难定位 3、网上解决方案较少。
1、快速构建项目 2、与主流开发框架无配置集成 3、可以独立运行项目，无需依赖外部servlet容器 4、极大的提高了开发、部署的效率 缺点：版本迭代太快，有时变动会比较大 ；因为不需要我们配置，报错时可能会无法定位   网上解决方案较少。
xml配置相比注解配置方式的优势？xml的优势：对象之间的关系一目了然；降低解耦，使方便扩展；xml配置的功能要比注解配置功能齐全 缺点：xml配置工作量要比注解配置方式多 注解配置：使开发、部署效率更快  缺点：如果对注解进行修改，则需要重新编译整个项目；业务类之间的关系没有xml配置一目了然；注解配置可能没有xml配置功能齐全。
springboot的单例和多例模式怎么设置？在controller层上使用注解@scope,默认是单例，设置成多例将value值为prototype；
spring中bean的类型：singleton：spring中IOC容器中只有一个bean实例，每次都只会返回这个唯一的实例，即单例模式 ；prototype：多例模式，每次都创建一个新的实例 ；request：适用于webapplicationContext环境，根据不同的请求对象创建不同的实例； session：适用于applicationContext环境，根据不同的会话对象创建不同的实例。global-session：一般适用于portlet环境，该作用域仅适用于webApplicationContext环境。
分布式和集群的关系？分布式就是将一个业务分成多个子模块部署在不同的服务器上；集群就是多个服务器组合在一起提供同一种服务。
乐观锁是假设数据在一般情况下不会发生冲突的，只有在提交更新的时候，才会对数据冲突的是否进行检测，然后把错误信息返回给用户，让用户决定如何去做。
项目中的问题：比如我负责的购物模块，不能不考虑的问题就是超卖问题，我是用乐观锁的概念解决的。就是假设数据在一般情况下是不会发生冲突的，只要数据在提交更新的时候，才会对数据的冲突与否进行检测，如果发生了冲突，就把错误的信息返回给用户。让用户决定怎么做。还有一个不是我负责的模块，是与我一块负责后端的同事，这个问题是我和他一起解决的。就是当一个用户的登录超过3次时，起初我们是在数据库中设置一个字段是否可用的状态，但是感觉不太对，于是就将如果超过三次都登入错误的用户，就将用户登录信息存入到redis中，然后设置一个过期时间（EXPIRE)，在此期间，此用户是不能登录的，每次登录都会判断redis中有没有这个用户，如果有，则提示此账户状态是冻结的。
ElasticSearch的正向索引和倒排索引：正向索引就是你搜索一个关键字，搜索引擎会搜索网页的每一个关键字，如果一个网页有成千上万个关键字，那效率会很低，所以一般不常用；倒排索引就是把拥有这个关键字的网页快速检索出来，为相关度和权重计算做基础，大大提高了工作效率。
ElasticSearch--Indices（索引）--type（类型）--document（文档）--Fields(字段)；Elasticsearch是基于lucene的开源搜索引擎。
全文检索：就是对全文字段进行检索找出匹配度最高的文档。
JPA是ORM规范，而不是ORM框架，Hibernate是JPA的一种实现，JPA就是Hibernate的一种集成。SpringDateJPA就是spring框架对JPA的整合。就是在JPA的规范下提供Reposity层的实现。
shiro是java的一个安全框架，可以用来完成授权、加密、认证、会话管理、与web集成、缓存等功能。
shiro权限注解1、@RequiresRoles：验证用户身份  @RequiresAuthentiction:验证用户状态是否登录  @RequiresUser:验证用户是否被记忆，也就是登录状态或RememberMe状态；@RequiresGuest：仅未登录状态可以访问；@RequiresPermissions：验证用户是否有权限。
C/S应用程序和B/S应用程序的区别？C/S是Client/Server,就是客户机和服务器，客户端需要安装客户端和所需环境才能访问服务器。B/S就是Browser/Server,就是浏览器和服务器，不需要下载客户端软件，只需要一个浏览器，大部分事务逻辑处理放在后端服务器。
Nginx是一个高性能的Http和反向代理服务器。
spring的七大模块：springCore、springContext、springDao、springORM、springAop、springWeb、SpringMVC
spring是开源框架，可以减少程序员的工作量，提高开发效率，spring同时也是分层框架，即对应的层处理对应的业务逻辑。spring的核心是IOC和AOP,IOC就是控制反转。IOC强调的是对象之间的关系是由容器管理的，容器管理对象，获取外部资源，反转则是传统编程中是由我们开发人员创建对象获取依赖关系，现在则是由容器创建对象注入依赖关系，正是容器查找和注入依赖关系，对象被获取，就是反转。
AOP就是面向切面编程，主要负责系统层的业务，比如日志、权限、事务等。切面就是将封装好的对象剖开，把对多个对象产生影响的共同行为提取并封装，就是切面。也就是将与业务逻辑无关，但是又被业务模块共同调用的逻辑提取并封装，这样可以减少代码的重复性、降低模块之间的耦合性，提高系统组件的可维护性。
hashMap是线程不安全的，是由数组+链表+红黑树（jdk1.8以后加入）实现的，按照哈希表进行排序的，允许key为null。
spring多种方式注入值：一种是设值注入，IOC容器调用属性的setter（）注入值；一种是构造注入，IOC容器调用构造器来注入。
单例模式：确保这个类只有一个对象并且自行实例化，并向整个应用系统提供这个实例。有懒汉式和饿汉式。
